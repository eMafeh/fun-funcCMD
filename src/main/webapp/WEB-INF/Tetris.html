<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Tetris</title>
    <style>
        .title {
            height: 40px;
            width: 100%;
            background: lightskyblue;

            font-size: xx-large;
        }

        input {
            width: 50px;
        }

        #table {
            position: absolute;
            left: 100px;
            top: 100px;
        }

        .cell {
            float: left;
            margin: 0;

            padding: 0;
            border: 1px solid #E2E2E2;
            height: 10px;
            width: 10px;
        }
    </style>
</head>
<body>
<div class="title">俄罗斯方块</div>
<button id="changeAuto"></button>
<button id="clearAll">清空</button>
<label for="loopTime">运行周期(ms):</label><input id="loopTime"/>
<span>运行数:</span><span id="allCount"></span>
<div id="table"></div>
</body>
<script>
    let auto = true;
    const changeAutoElement = document.getElementById("changeAuto");
    {
        changeAutoElement.onclick = () => changeAutoElement.innerHTML = (auto = !auto) ? "暂停" : "开始";
        changeAutoElement.click();
    }

    let timeout = 200;
    const loopTimeElement = document.getElementById("loopTime");
    {
        loopTimeElement.onchange = () => {
            let value = loopTimeElement.value;
            if (Number.isInteger(value) && value > 0)
                loopTimeElement.value = timeout;
            else timeout = value;
        };
        loopTimeElement.value = timeout;
    }
    let allCount = 0;
    const allCountElement = document.getElementById("allCount");

    document.getElementById("clearAll").onclick = () => {
        if (auto) changeAutoElement.click();
        lifeCellForEach(removeLife);
        allCount = 0;
        allCountElement.innerHTML = allCount;
    };
    let worldX = 30;
    let worldY = 50;
    let cellSize = 12;


    class TetrisView {

        constructor(tableId, xSize, ySize) {
            this.tableId = tableId;
            this.table = document.getElementById(tableId);
            this.xSize = xSize;
            this.ySize = ySize;
            this.cells = [];
            this.origin = [this.xSize / 2, 1];
            this.shapeMap = {};
            let cells = "";
            for (let iy = 1; iy <= ySize; iy++)
                for (let ix = 1; ix <= xSize; ix++)
                    cells += `<div class="cell" id="${tableId}_${ix}_${iy}"></div>`;
            this.table.style.width = xSize * cellSize + "px";
            this.table.style.height = ySize * cellSize + "px";

            this.table.innerHTML = cells;
            //记录所有的元胞格子 td = tdElements[x][y]
            for (let x = 1; x <= xSize; x++) {
                let cellX = this.cells[x] = [];
                for (let y = 1; y <= ySize; y++)
                    cellX[y] = {
                        ele: document.getElementById(`${tableId}_${x}_${y}`),
                        belong: null
                    }
            }
        }

        tryMoveCells(shapeId, shape, origin) {
            let xIndex = origin[0];
            let yIndex = origin[1];
            // 检查下部
            if (yIndex - 1 > this.ySize) {
                // 该形状一定超过了最下面,nothing to do
                return;
            }

            //检查左右
            const left = shape.getLeft() + xIndex - 1;
            //最左边必须大于1
            if (left < 0) xIndex -= left;
            const right = shape.getRight() + xIndex - this.xSize;
            //最右边必须小于 xSize
            if (right > 0) xIndex -= right;
            //左边不大于1 , 说明shape 形状太大
            if (xIndex < 1) {
                console.log("shape size is big than view", shape, origin);
                return;
            }

            //检查每个 cell 是否可用
            const cells = [];
            for (const cell of shape.cells) {
                const xKey = cell[0] + xIndex;
                const yKey = cell[1] + yIndex;
                if (yKey < 1) {
                    //不需要展示,跳过该块
                    continue;
                }
                const cellElement = this.cells[xKey][yKey];
                if (cellElement.belong && cellElement.belong !== shapeId) {
                    // 依赖到被占用的块,什么也不做
                    return;
                }
                cells.push([xKey, yKey]);
            }

            //更新 origin 对象
            origin[0] = xIndex;
            origin[1] = yIndex;

            //实际移动 cell 记录移动情况
            const oldCells = this.shapeMap[shapeId];
            if (oldCells) {
                for (const cell of oldCells) {
                    const cellElement = this.cells[cell[0]][cell[1]];
                    cellElement.belong = null;
                    cellElement.ele.style.backgroundColor = null;
                }
            }
            for (const cell of cells) {
                const cellElement = this.cells[cell[0]][cell[1]];
                cellElement.belong = shapeId;
                cellElement.ele.style.backgroundColor = 'black';
            }
            this.shapeMap[shapeId] = cells;
            //成功操作
            return true;
        }
    }

    /**
     * 一个固定的形状,由一系列 cell 构成,
     * 记录最左坐标,最右坐标,
     * 并调整最下坐标为-1,保证最低处一行为-1
     */
    class Shape {
        constructor(...cells) {
            this.cells = cells;
            let left = 0;
            let right = 0;
            let down = -1;
            for (const cell of cells) {
                const xKey = cell[0];
                left = Math.min(xKey, left);
                right = Math.max(xKey, right);
                down = Math.max(cell[1], down);
            }
            if (down !== -1) {
                console.log("fix down index to -1", cells);
                for (const cell of cells)
                    cell[1] -= down + 1;
            }
            this.getLeft = () => left;
            this.getRight = () => right;
        }
    }

    class ShapeGroup {
        constructor(...shapeList) {
            this.shapeList = shapeList;
            if (!ShapeGroup.groups) ShapeGroup.groups = [];
            ShapeGroup.groups.push(this);
        }

        randomIndex() {
            return Math.floor(Math.random() * this.shapeList.length);
        }

        getShape(index) {
            return this.shapeList[(index + 1) % this.shapeList.length];
        }

        static random() {
            return ShapeGroup.groups[Math.floor(Math.random() * ShapeGroup.groups.length)];
        }
    }

    //初始化所有形状群
    {
        //四方
        new ShapeGroup(
            new Shape([0, -1], [0, -2], [1, -1], [1, -2])
        );
        //直线
        new ShapeGroup(
            new Shape([0, -1], [0, -2], [0, -3], [0, -4]),
            new Shape([-1, -1], [0, -1], [1, -1], [2, -1])
        );
        //L直角
        new ShapeGroup(
            new Shape([0, -1], [1, -1], [0, -2], [0, -3]),
            new Shape([0, -1], [1, -1], [2, -1], [2, -2]),
            new Shape([0, -3], [1, -3], [1, -2], [1, -1]),
            new Shape([0, -1], [0, -2], [1, -2], [2, -2])
        );
        //J直角
        new ShapeGroup(
            new Shape([0, -1], [1, -1], [1, -2], [1, -3]),
            new Shape([2, -1], [0, -2], [1, -2], [2, -2]),
            new Shape([0, -1], [0, -2], [0, -3], [1, -3]),
            new Shape([0, -1], [0, -2], [1, -1], [2, -1])
        );
        //左勾 Z
        new ShapeGroup(
            new Shape([0, -2], [1, -2], [1, -1], [2, -1]),
            new Shape([0, -1], [0, -2], [1, -2], [1, -3])
        );
        //右勾
        new ShapeGroup(
            new Shape([0, -1], [1, -1], [1, -2], [2, -2]),
            new Shape([0, -3], [0, -2], [1, -2], [1, -1])
        );
        //山
        new ShapeGroup(
            new Shape([0, -1], [1, -1], [-1, -1], [0, -2]),//上
            new Shape([0, -1], [0, -2], [0, -3], [-1, -2]),//左
            new Shape([0, -1], [1, -2], [-1, -2], [0, -2]),//下
            new Shape([0, -1], [0, -2], [0, -3], [1, -2])//右
        );
    }

    let shapeId = 0;

    class Status {
        constructor(view) {
            this.view = view;
            this.shapeId = ++shapeId;
            this.shapeGroup = ShapeGroup.random();
            this.index = this.shapeGroup.randomIndex();
            this.origin = [view.origin[0], view.origin[1]];
        }

        toRotation() {
            const result = this.view.tryMoveCells(this.shapeId, this.shapeGroup.getShape(this.index + 1), this.origin);
            return this.handleResult(result, () => this.index++);
        }

        toNext() {
            const result = this.view.tryMoveCells(this.shapeId, this.shapeGroup.getShape(this.index), [this.origin[0], this.origin[1] + 1]);
            return this.handleResult(result, () => this.origin[1]++);
        }

        toLeft() {
            const result = this.view.tryMoveCells(this.shapeId, this.shapeGroup.getShape(this.index), [this.origin[0] - 1, this.origin[1]]);
            return this.handleResult(result, () => this.origin[0]--);
        }

        toRight() {
            const result = this.view.tryMoveCells(this.shapeId, this.shapeGroup.getShape(this.index), [this.origin[0] + 1, this.origin[1]]);
            return this.handleResult(result, () => this.origin[0]++);
        }

        handleResult(result, callBackSuccess) {
            if (result === true) {
                callBackSuccess();
                return this;
            }
            return new Status(this.view);
        }
    }

    const view = new TetrisView("table", worldX, worldY);

    let status = new Status(view);
    const whileLifeLoop = () => {
        if (auto) status = status.toNext().toRotation();
        setTimeout(whileLifeLoop, timeout);
    };
    whileLifeLoop();



</script>
</html>