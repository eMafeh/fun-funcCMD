<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Tetris</title>
    <style>
        .title {
            height: 40px;
            width: 100%;
            background: lightskyblue;

            font-size: xx-large;
        }

        input {
            width: 50px;
        }

        #table {
            position: absolute;
            left: 100px;
            top: 100px;
        }

        .cell {
            float: left;
            margin: 0;

            padding: 0;
            border: 1px solid #E2E2E2;
            height: 10px;
            width: 10px;
        }
    </style>
</head>
<body>
<div class="title">俄罗斯方块</div>
<button onclick="lifeLoop(true)">下一个世代</button>
<button id="changeAuto"></button>
<button id="clearAll">清空</button>
<label for="loopTime">运行周期(ms):</label><input id="loopTime"/>
<span>运行数:</span><span id="allCount"></span>
<div id="table"></div>
</body>
<script>

    let worldX = 50;
    let worldY = 15;
    let cellSize = 12;


    class TetrisView {

        constructor(tableId, xSize, ySize) {
            this.tableId = tableId;
            this.table = document.getElementById(tableId);
            this.xSize = xSize;
            this.ySize = ySize;
            this.cells = [];
            this.origin = [this.xSize / 2, 1];
            this.staticCell = {};

            let cells = "";
            for (let iy = 1; iy <= ySize; iy++)
                for (let ix = 1; ix <= xSize; ix++)
                    cells += `<div class="cell" id="${tableId}_${ix}_${iy}"></div>`;
            this.table.style.width = xSize * cellSize + "px";
            this.table.style.height = ySize * cellSize + "px";

            this.table.innerHTML = cells;
            //记录所有的元胞格子 td = tdElements[x][y]
            for (let x = 1; x <= xSize; x++) {
                let cellX = this.cells[x] = [];
                for (let y = 1; y <= ySize; y++)
                    cellX[y] = document.getElementById(`${tableId}_${x}_${y}`);
            }
        }

        unoccupied(xKey, yKey) {
            if (xKey < 1 || xKey > this.xSize || yKey < 1 || yKey > this.ySize) {
                //未定义的格子
                return null;
            }
            //为 true 则 占用
            return this.staticCellStatus(xKey, yKey) !== true;
        }

        liveLife(xKey, yKey) {
            this.staticCellStatus(xKey, yKey, true);
            this.cells[xKey][yKey].style.backgroundColor = 'black';
        }

        removeLife(xKey, yKey) {
            this.staticCellStatus(xKey, yKey, null);
            this.cells[xKey][yKey].style.backgroundColor = null;
        }

        staticCellStatus(xKey, yKey, value) {
            let cellX = this.staticCell[xKey];
            if (!cellX) cellX = this.staticCell[xKey] = {};
            const oldValue = cellX[yKey];
            if (value !== undefined) {
                cellX[yKey] = value;
            }
            return oldValue;
        }
    }

    class SquareShape {
        constructor(view) {
            this.shapeGroup = SquareShape.shapeGroups[Math.floor(Math.random() * SquareShape.shapeGroups.length)];
            this.index = Math.floor(Math.random() * this.shapeGroup.length);
            this.tetrisView = view;
        }

        begin() {
            this.origin = this.tetrisView.origin;
            this.moveCells = [];
        }

        rotation() {

        }

        next() {

        }

        left() {

        }

        right() {

        }

        down() {

        }

        showShape(squareOrigin, tetrisView) {
            this.moveCells = [];
            for (let i = 0; i < this.shapeGroup.length; i++) {
                let xKey = this.shapeGroup[i][0] + squareOrigin[0];
                let yKey = this.shapeGroup[i][1] + squareOrigin[1];
                const unoccupied = tetrisView.unoccupied(xKey, yKey);
                console.log(xKey, yKey);
                if (unoccupied === true) {
                    this.moveCells.push([xKey, yKey]);
                    tetrisView.liveLife(xKey, yKey);
                }
            }
            if (this.moveCells.length === 0) return true;
        }
    }

    SquareShape.shapeGroups = [
        //四方
        [
            [[0, -1], [0, -2], [1, -1], [1, -2]]
        ],
        //直线
        [
            [0, -1], [0, -2], [0, -3], [0, -4],
            [-1, -1], [0, -1], [1, -1], [2, -1]
        ],
        //L直角
        [
            [0, -1], [1, -1], [0, -2], [0, -3],
            [0, -1], [1, -1], [2, -1], [2, -2],
            [0, -3], [1, -3], [1, -2], [1, -1],
            [0, -1], [0, -2], [1, -2], [2, -2],
        ],
        //J直角
        [
            [-1, 2], [-1, 1], [-1, 0], [0, 0]
        ],
        //左勾
        [
            [0, 1], [0, 2], [-1, 1], [-1, 0]
        ],
        //右勾
        [
            [-1, 1], [-1, 2], [0, 1], [0, 0]
        ],
        //山
        []
    ];

    const view = new TetrisView("table", worldX, worldY);


    const lifeCell = {};

    let auto = true;
    const changeAutoElement = document.getElementById("changeAuto");
    {
        changeAutoElement.onclick = () => changeAutoElement.innerHTML = (auto = !auto) ? "停止运行" : "自动运行";
        changeAutoElement.click();
    }

    let timeout = 500;
    const loopTimeElement = document.getElementById("loopTime");
    {
        loopTimeElement.onchange = () => {
            let value = loopTimeElement.value;
            if (Number.isInteger(value) && value > 0)
                loopTimeElement.value = timeout;
            else timeout = value;
        };
        loopTimeElement.value = timeout;
    }
    let allCount = 0;
    const allCountElement = document.getElementById("allCount");

    document.getElementById("clearAll").onclick = () => {
        if (auto) changeAutoElement.click();
        lifeCellForEach(removeLife);
        allCount = 0;
        allCountElement.innerHTML = allCount;
    };

    const isLife = (xKey, yKey) => lifeCell[xKey] && lifeCell[xKey][yKey] === true;

    const lifeCellForEach = forEach => {
        let rowX;
        for (const xKey in lifeCell)
            if (lifeCell.hasOwnProperty(xKey) && (rowX = lifeCell[xKey]))
                for (const yKey in rowX)
                    if (rowX.hasOwnProperty(yKey) && rowX[yKey] === true)
                        forEach(xKey, yKey);
    };
    const lifeLoop = handle => {
        if (!auto && !handle) return;

        allCount++;
        const countCell = {};
        //计数方法
        const count = (xKey, yKey) => {
            const rowX = countCell[xKey];
            if (rowX) {
                const num = rowX[yKey];
                rowX[yKey] = num ? num + 1 : 1;
            } else {
                const newY = {};
                newY[yKey] = 1;
                countCell[xKey] = newY;
            }
        };

        //标记下一轮有值的元胞数
        lifeCellForEach((xKey, yKey) => {
            const xNum = xKey / 1;
            const yNum = yKey / 1;
            //获取相邻8点xy下标
            const leftKey = (xNum > 1 ? xNum - 1 : worldX) + "";
            const rightKey = (xNum < worldX ? xNum + 1 : 1) + "";
            const topKey = (yNum > 1 ? yNum - 1 : worldY) + "";
            const bottomKey = (yNum < worldY ? yNum + 1 : 1) + "";
            //上面三个
            count(leftKey, topKey);
            count(xKey, topKey);
            count(rightKey, topKey);
            //左右两个
            count(leftKey, yKey);
            count(rightKey, yKey);
            //下面三个
            count(leftKey, bottomKey);
            count(xKey, bottomKey);
            count(rightKey, bottomKey);
        });

        //新的活胞
        for (let x = 1; x <= worldX; x++) {
            const xKey = x + "";
            const rowX = countCell[xKey];
            if (!rowX) continue;
            for (let y = 1; y <= worldY; y++) {
                const yKey = y + "";
                autoChange(rowX[yKey], xKey, yKey);
            }
        }
        allCountElement.innerHTML = allCount;
    };

    const autoChange = (num, xKey, yKey) => {
        if (isLife(xKey, yKey)) {
            if (num !== 2 && num !== 3)
                removeLife(xKey, yKey);
        } else if (num === 3)
            liveLife(xKey, yKey);
    };

    let squareShape = new SquareShape(view);

    let y = 0;
    const whileLifeLoop = () => {
        squareShape.clear(view);
        y++;

        let b = squareShape.showShape(, view);
        if (b === true) {
            squareShape = new SquareShape();
            y = 0;
        }
        setTimeout(whileLifeLoop, timeout);
    };
    whileLifeLoop();

</script>
</html>